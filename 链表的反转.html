<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    解法一 思路，实现链表的反转，递归调用互换的函数
    并且一定要记得让H.nextNULL，也就是断开现在指针的链接，
    否则新的链表形成了环，下一层H.next.next赋值的时候会覆盖后续的值。
    ---------------------------解法二------------------------------------
    原地反转法
  </body>
  <script>
    function createElement(ele) {
      this.element = ele
      this.next = null
    }
    class LinkList {
      constructor() {
        this.length = 0 //链表长度
        this.head = null //头
      }
      append(node) {
        if (this.head === null) {
          this.head = node
        } else {
          //找到最好一项再添加
          let current = this.head
          while (current.next) {
            current = current.next
          }
          current.next = node
        }
        this.length++
      }
      getHead() {
        return this.head
      }
    }
    let linkList = new LinkList()
    linkList.append(new createElement(1))
    linkList.append(new createElement(2))
    linkList.append(new createElement(3))
    linkList.append(new createElement(4))
    console.log(reverseLinkList(linkList.getHead()))
    function reverseLinkList1(head) {
      if (head === null || head.next === null) return head
      let prevNode = head.next
      let newHead = reverseLinkList(prevNode)
      prevNode.next = head
      head.next = null
      return newHead
    }

    function reverseLinkList2(head) {
      if (head === null || head.next === null) return head
      let node = head
      let prevNode = null
      while (node.next) {
        const nextNode = node.next
        node.next = prevNode
        prevNode = node
        node = nextNode
      }
      node.next = prevNode
    }
  </script>
</html>
